# General config options to define the server.
# Please copy to config.toml

[default]
# FQDN of the current hostname. (Note, AWS returns an invalid value
# for hostname)
# If this is not defined, app will also query environment $HOST value.
#current_host = "localhost"
# If you're running on Amazon, try pulling the public hostname from the
# metadata service
#use_aws_host = false
# Specifies whether the hostname should be resolved to an IP address.
#resolve_host = false

# This defines what endpoint to use for updates.
# {{.CurrentHost}} = the current host to connect to.
#        (note, in most cases, this should be the general cname for
#         the service, e.g. "push.services.mozilla.org") Only use
#         this field for debugging or development since this will
#         route endpoints to a specific box.
# {{.Token}} = the LSoC (long string of crap) that uniquely identifies a
#         UserAgentID (uaid) and ChannelID (chid).
#push_endpoint_template = "{{.CurrentHost}}/update/{{.Token}}"
# reply to pings with "{}" if push_long_pongs is false
#push_long_pongs = false

# define this to encode the Primary Key / ChannelID combo
# this is a valid 16, 24, or 32 []byte created by crypto/rand.Read()
# This key can be generated by running go run tools/genKey/main.go
# e.g.
#token_key = "W8FfY9Tw9PtMSEFJF0MAkw=="

# Minimum time between pings (0 == no minimum ping interval)
# Clients that ping more frequently than this will have their socket closed
# and may be considered "hostile".
#client_min_ping_interval = "20s"
## Timeout socket if not recv'd hello
#client_hello_timeout = "30s"
# Client Pong Interval is the period for when the server should send a text
# ping frame. Set to "0" for no server pings
#client_pong_interval = "5m"

[websocket]
# A list of allowed WebSocket origins. An empty list allows all origins;
# otherwise, the scheme, hostname, and port specified in the client's
# `Origin` header must match at least one allowed origin.
#origins = []

[websocket.listener]
# The WebSocket listener address and port. 0.0.0.0 = all interfaces
addr = ":8080"
# The maximum number of concurrent connections that this listener can
# accept before waiting for existing connections to close.
#max_connections = 1000
# The TCP keep-alive period for WebSocket connections.
#tcp_keep_alive = "3m"
# Paths to SSL certificate files.
#cert_file = "certs/test.crt"
#key_file = "certs/test.key"

[endpoint]
# Maximum allowed data segment (in bytes)
#max_data_len = 4096

[endpoint.listener]
addr = ":8081"
#max_connections = 1000
#tcp_keep_alive = "3m"
#cert_file = "certs/test.crt"
#key_file = "certs/test.key"

# Proprietary pings
[propping]
# Do nothing (default)
type = "noop"

# GCM config used for android proprietary pings (EXPERIMENTAL)
#[propping]
#type = gcm
#ttl = "72h"
#collapse_key = "simplepush"
#dry_run = false
#api_key = "YOUR_API_KEY"
#url = "https://android.googleapis.com/gcm/send"
#idle_conns = 50

# Carrier-specific UDP pings
#[propping]
#type = udp
#url = "vendor provided URL here"

# Standard output logging.
[logging]
type = "stdout"
# Available log message formats:
# protobuf = Heka Protobuf encoding.
# json = Heka JSON encoding.
# text = Human-readable, text-only format.
format = "protobuf"
# The Heka message envelope version. Ignored if format = "text".
env_version = "2"
# Ignore messages above this syslog severity level (0=Emergency...7=Debug)
filter = 2
# The LogName to use for this product.
#name = "pushgo"

# Remote logging: sends log messages to a remote Heka instance over TCP, UDP,
# or a Unix domain socket.
#[logging]
#type = "net"
#format = "protobuf"
#name = "myenv"
# proto may be set to any protocol accepted by net.Dial or tls.Dial.
#proto = "tcp"
#addr = "heka_tcp_input:1234"
#use_tls = false
#env_version = "2"
#filter = 2

# Local file logging.
#[logging]
#type = "file"
#format = "protobuf"
#path = "/var/log/pushgo.log"
#env_version = "2"
#filter = 2

# no storage
[storage]
type = "none"
# Maximum number of client channels before we send a re-registration request
#max_channels = 200

# Use the gomc library; requires local libmemcache 1.0.6
#[storage]
#type = "memcache_gomc"
#max_channels = 200
# Use the AWS Elasticache node discovery discovery system. This will use
# the values specified in storage.memcache.server as "backup" in case the
# call fails.
#elasticache_config_endpoint = ""

# "memcache_gomc"-specific settings.
#[storage.memcache]
# Memcache data servers
# multiple memcache servers can be appended with commas (e.g.
# ["10.0.0.1:11211", "10.0.0.2:11211", ... ]  )
#server = ["127.0.0.1:11211"]
# Number of connections to pool per server
# a connection is a socket to a remote memcache server. Obviously, this
# decreases the number of sockets available
#max_connections = 100

# Memcache timeouts
# WARNING: Memcache is VERY SENSITIVE about these timeouts, improperly high
# settings will cause INVALID ARGUMENTS errors
#recv_timeout = "5s"
#send_timeout = "5s"
#poll_timeout = "15ms"
#retry_timeout = "5s"

# Use the go native memcache library; does not require local libmemcache
#[storage]
#type = "memcache_memcachego"
#max_channels = 200
#elasticache_config_endpoint = ""

# "memcache_memcachego"-specific settings.
#[storage.memcache]
#server = ["127.0.0.1:11211"]

# Common storage settings for "memcache_gomc" and "memcache_memcachego".
#[storage.db]
# "live" records timeout in 3 days
#timeout_live = 259200
# "registrations" timeout in 3 hours. If an app server does not send an
# update within this timeout, the channel will be dropped.
#timeout_reg = 10800
# "deleted" records time out in 1 day
#timeout_del = 86400
# The time to wait when acquiring a connection from the memcached pool.
#handle_timeout = 5s
# The key prefix for proprietary pings.
#prop_prefix = "_pc-"

[router]
# Default router to use, the rest of the options assume the broadcast
# router
# type = "broadcast"
# Default host to shard users to, defaults to global hostname above
#default_host = "localhost"
# Fail a route connection attempt after timeout seconds
#ctimeout = "3s"
# Fail a route processing attempt after timeout seconds
#rwtimeout = "3s"
# how big a "bucket" of servers to try in one go.
# Note: buckets should be between 10 and 50 servers
# (31MM hosts divided by 200K means ~155 servers, so bucket_size of 10
# means 16 buckets. Have fun with probability tables to figure out the
# size that works best for you.)
#bucket_size = 10
# Maximum allowed data segment (in bytes)
#max_data_len = 4096
# Number of idle connections to maintain per host.
#idle_conns = 50

[router.listener]
# Default interface and port for shard routing
# (NOTE: the port should not be publicly accessible)
#addr = ":3000"
#max_connections = 1000
#tcp_keep_alive = "3m"
#cert_file = ""
#key_file = ""

[discovery]
type = "static"
# Static list of peer Simple Push servers.
#contacts = []

#[discovery]
#type = "etcd"
# The etcd root directory containing peer Simple Push nodes. Nodes belonging
# to the same cluster should use the same directory.
#dir = "push_hosts"
# list of absolute etcd server URLs
#servers = ["http://localhost:4001"]
# Simple Push nodes should be considered "valid" for this period
#defaultTTL = "1m"
# The polling interval for new nodes.
#refresh_interval = "10s"
# Time to wait after removing the host from etcd during shutdown. Should
# be 1-2 times the refresh_interval.
#close_delay = "20s"

#[discovery.retry]
#retries = 5
#delay = "200ms"
#max_delay = "5s"
#max_jitter = "400ms"

[metrics]
# The statsd client name, prepended to all metric names.
#statsd_name = "undef"
# Optional prefix for metric names, appended to the client name.
#prefix = "myhostname.simplepush"
#statsd_server = "heka_statsdinput_host:1234"

[balancer]
type = "none"

#[balancer]
#type = "etcd"
#servers = ["http://localhost:4001"]
# The maximum amount of time that published client counts will be
# considered valid.
#ttl = "1m"
# The connected client threshold. Once exceeded, connecting clients will be
# redirected to hosts with the fewest connections.
#threshold = 0.95
# The client count publication interval.
#update_interval = "10s"
# Time to wait after removing client counts from etcd during shutdown. Should
# be 1-2 times the update_interval.
#close_delay = "20s"

#[balancer.retry]
#retries = 5
#delay = "200ms"
#max_delay = "5s"
#max_jitter = "400ms"
